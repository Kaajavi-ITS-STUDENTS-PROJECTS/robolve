Junio
Do 5 - 7:30 hs
  - setup de sprites basicos 4:15 hs
  - programacion inicial de clase robot - 3:15 hs
Vi 10 - 3:30 hs
  - Tiled, intento de mapa - 3:30 hs
Sa 11 - 8 hs
  - Mapa funcional, zoom, smooth scroll - 5 hs
  - Intento de limitar bordes - 1:30 hs
  - Cabeza triangulo y arreglo de la estructura del blend 1:30 hs
Do 12 - 6 hs
  - Sin avances en zoom y limite del scroll - 4hs
  - Limite scroll funcional - 2hs
Ju 23 - 2 hs
  - Spawnear robot

Julio
Sa 2 - 2:40 hs
  - Setear stats estaticos a los robots funcionando - 1:40 hs
  - Diferenciar sprites con color - 1 hs
Do 3 - 3:10 hs
  - Sprite y spawn de defensa - 1:05 hs
  - Health bar - 2:05 hs
Lu 4 - 5:10 hs
  - Debug circle, inicio de logica para el rango y muerte - 2 hs
  - Detectar enemigo en rango y seleccionar target - 2:30
  - hacer que la vida empieze a bajar, y spawnRandomRobot - 40 min
Ma 5 - Comienzo GA - 2 hs
  - Zoom tactil previsorio y predise単o antes de empezar con el GA - 1 hs
  - Planificacion y como seguir adelante - 1 hs
Mi 6 - 4:30 hs
  - Clase Debugger - 4 hs
  - Sprite de la Base - 30 min
Ju 7 - 1 hs
  - Inicio de la clase base - 1 hs
Vi 8 - 35 min
  - algo relacionado a los tilemaps pero en definitiva nada - 35 min
Sa 9 - 4:15 hs
  - Redimensionados los tiles del mapa a 132x132 - 1:30 hs
  - Spawn points centrados - 2 hs
  - Simular healthbar 3d - 0:20 hs
  - Cuando llega al spawn el robot comienza a pegar - 0:25 hs
Do 10 - 1 hs
  - ver como hacer lo de turn - 1 hs
Ma 12 - 5:10 hs
  - inicio de turn, y mejora de tiles de mapa - 1:30 hs
  - Mejoras de spawn, debug point, entendimiento de isometric,
    problemas para conseguir un tile en la posicion actual del robot - 1:10 hs
  - canTurn funcionando - 1:20 hs
  - turn funcionando  - 50 min
  - dise単ando logica mejorada de turn - 20 min
Mi 13 - 6:05 hs
  - nueva funcion turn con logica mejorada - 1:15 hs
  - Inicio: Detectar entrada y salida del turntile - 1:15 hs
  - Debug rect on tile, y mid point de tile - 2:15 hs
  - Debug tile, Debug polygon, next to finish the turntile problem - 1:20 hs
Ju 14
  - Nada en particular, probando cosas con el mapa - 1:30 hs
  - spriteRectFromTile y mas pruebas - 1 hs
  - turn al fin funcionando de forma negra pero funcional - 1:10 hs
  - Invalid name error solved - 0:15 hs

Bugs prioritarios:
"Invalid name error"
draw circle error compilando a linux y android
health bar fondo blanco en linux android



|#spawnpoint y clase de nexo, sprite de nexo - 1:00 | 1:30
|#Crear clase padre para robot, defensa y 多base? - 2:00 | 4:00
|#Cuando llega al spawn el robot comienza a pegar - 2:00 | 0:25
|#Pathfinding de los robots hacia el nexo -  8 hs | 15:55 hs
  Se me ocurrio que no haya pathfinding si no que sea un atributo "probabilidad
  de giro"
|#Arreglar el spawn de los sprites y entender bien como funcionan los sprites
isometricos - 6 hs
#Definir oleadas - 2:00
#calcular el fitscore en base a cercania a la base(o distancia recorrida),
  da単o a la base, y tiempo sobrevivido - 8:00
#Funcion que te devuelve el robot resumido para poder archivarlos en el
  historial de forma liviana - 2:00
#Historial de hasta 10 oleadas para ir sacando informacion para comparar y sacar
  muestras para el proximo crossover, mientras mas lejana la oleada archivada
  menos individuos de esa oleada entran al crossover - 6:00 hs
#Roulete
#Crossover
#Mutacion
#Acordarme de guardar los valores de mutacion, crossover rate, y el peso de cada
  factor del fitscore, por partida asi despues puedo comparar dos o tres partidas
  agarrarlas y cruzarlas para que me de unos nuevos valores de mutacion etc.
  (tambien podria hacerlo cada tantas oleadas al cambio para ver que onda)
#Revisar los sprites antes de hacerlos como los voy a spawnear, com centrarlos
  en el tile del tilemap, y como saber cual es la profundidad, cual se tiene
  que mostrar arriba del otro y esas cosas fijarse en el libro de dropbox
  de cocos iphone.

USAR LA PREGUNA DE STACKOVERFLOW PARA UBICAR BIEN EN Z SEGUN X E Y


###BOLUDEO desarmar el piso
for (var i = 0; i < 10; i++) {
  randomX = Math.floor(Math.random()*20);
  randomY = Math.floor(Math.random()*20);
  randomZ = Math.floor(Math.random()*100);
  tile2 = this.getLayer("Background").getTileAt(cc.p(randomX,randomY));
  moveBy = cc.moveBy(2, cc.p(0, randomZ));
  tile2.runAction(moveBy);
}

###Logica del turn (como decide el robot cuando girar y cuando no)
DONE- IDEA: No poder volver hacia atras a menos que sea el unico camino
(
  Tener lista con las direcciones contrarias
  0 : 2
  1 : 3
  2 : 0
  3 : 1
  si estoy yendo por 2 y entro a un turn tile (0,1,2,3)
    no puedo volver por 0 (0 es contrario de 2)
    tirar random, si es mas chico que mi turnProb significa que tengo que doblar
    puedo doblar en las posiciones 1 y 3, (ni la actual ni el contrario)
    si no, seguir por 2
  si estoy yendo por 2 y entro a un turn tile (0,1,2)
    mismo procedimiento que arriba
  si estoy yendo por 2 y entro a un turn tile (0,1)
    como 2 (actual pointing) no aparece en la lista estoy obligado a ir por 1
  si estoy yendo por 2 y entro a un turn tile (0)
    ahora si estoy obligado a volver por donde vine

  ENTONCES:
    si this.pointing esta en la turnTile
      si hay un lugar al que doblar y mi random dice que doble
        doblar a alguno de esos lugares al azar
    si this.pointing no esta en la turnTile
      si hay un lugar al que doblar
        doblar a alguno de esos lugares al azar
      si no
        volver por donde vine
)
